# Лабораторная работа №1

## Дано

1. Три текста на английском, немецком и неизвестном языках
2. Необходимо определить, на каком языке написан последний текст с помощью 
союзов, предлогов, артиклей и других частотных слов, характерных для конкретного языка


## Что надо сделать

### Шаг 0. Подготовка (проделать вместе с преподавателем на практике).

1. Создать форк репозитория
2. Установить необходимые инструменты для работы
3. Изменить файлы `main.py` и `start.py`
4. Закоммитить изменения и создать pull request

**Важно:** в файле `start.py` вы должны написать код, определяющий язык неизвестного текста. 
Для этого реализуйте функции в модуле `main.py` и импортируйте их в `start.py`.
Весь код, выполняющий детектирование языка, должен быть выполнен в блоке `__main__`:

```py
if __name__ == '__main__':
  # your code goes here
  pass
 ```

В рамках данной лабораторной работы **НЕЛЬЗЯ использовать сторонние модули и модуль collections.**


### Шаг 1. Токенизировать текст. 

Функция принимает на вход текст в виде строки.

Функция должна возвращать список слов (токенов) без знаков препинания в нижнем регистре.

Токены могут состоять только из букв английского, немецкого и классического латинского алфавитов
(не допускаются цифры и любые другие символы внутри слова).
При этом любые символы (кроме букв) внутри токена удаляются, например, don't заменяется на dont, round-up на roundup и т.д.

Если на вход подаются некорректные значения, возвращается `None`.

Интерфейс: 
```py
def tokenize(text: str) -> list or None:
  pass
```

### Шаг 2. Получить список токенов без стоп-слов.

Функция принимает на вход список токенов и список стоп-слов.

Функция должна возвращать список токенов без стоп-слов. 

Если на вход подаются некорректные токены, возвращается `None`.

Если на вход подаются некорректные стоп-слова, возвращается список токенов без изменений.
Пустой список стоп-слов не считается некорректным значением.


Интерфейс: 
```py
def remove_stop_words(tokens: list, stop_words: list) -> list or None:
  pass
```


### Шаг 3. Получить частотный словарь по заданному тексту.

Функция принимает на вход список токенов.

Функция должна возвращать частотный словарь, где ключ - токен, значение - число (частота).

Если на вход подаются некорректные токены, возвращается `None`.


Интерфейс: 
```py
def calculate_frequencies(tokens: list) -> dict or None:
  pass
```


### Шаг 4. Получить список первых N по популярности слов. Выполнение Шагов 1-4 соответствует 4 баллам

Функция принимает на вход частотный словарь и число топ N слов.

Функция возвращает список первых N по популярности слов.
Первый элемент списка - самое популярное слово. 
Последний элемент списка - N-ное по популярности слово.
Если число N больше числа слов в словаре, 
то возвращаются все слова в порядке убывания их частоты. 

Если на вход подаются некорректные значения, возвращается `None`.

Интерфейс: 
```py
def get_top_n_words(freq_dict: dict, top_n: int) -> list or None:
  pass
```


### Шаг 5. Создать профиль конкретного языка.

Профиль языка – это структура с информацией о конкретном языке.
Подобная простейшая языковая модель часто используется в задаче определения языка.
В настоящей лабораторной работе профиль языка состоит из названия языка, частотного словаря
и количества токенов в данном словаре.

В дальнейших лабораторных работах вы будете работать с другими языковыми профилями.
Пример языковых профилей вы можете найти в следующем проекте (profiles): https://github.com/shuyo/language-detection.
Несмотря на то, что данные профили содержат информацию о n-граммах, 
с которыми мы познакомимся позднее, структура этих профилей аналогична.

Профиль языка представляется следующим образом:
```
{"name": "en",
"freq": {"happy": 2, "the": 1},
"n_words": 2}
```
где ключу `"freq"` соответствует значение – частотный словарь, 
ключу `"n_words"` – количество токенов в словаре,
ключу `"name"` – название языка.

В данной лаборатной работе языковой профиль **обязательно** представляет собой словарь,
который содержит три ключа – `"freq"`, `"n_words"` и `"name"`.

Функция принимает на вход язык в виде строки, текст в виде строки и список стоп-слов.

Функция должна возвращать словарь с вышеназванной структурой. 

Если на вход подаются некорректные значения, возвращается `None`.
Пустой список стоп-слов не считается некорректным значением.

Первоначально текст необходимо токенизировать, стоп-слова необходимо удалить.
Для этого необходимо использовать функции `tokenize` и `remove_stop_words`.

Для получения частотного словаря необходимо использовать функцию `calculate_frequencies`.

Интерфейс: 
```py
def create_language_profile(language: str, text: str, stop_words: list) -> dict or None:
  pass
```


### Шаг 6. Сравнить два языковых профиля

Для сравнения языковых профилей необходимо найти долю пересекающихся частотных слов.

Для этого необходимо разделить количество общих токенов на длину списка токенов на неизвестном языке.
Например, если топ N слов для английского языка – `['a', 'an', 'the', 'by']`, 
а для неизвестного – `['an', 'the', 'with', 'is']`. Количество общих токенов – `2` (`['an', 'the']`), 
длина списка токенов на неизвестном языке – `4`. Тогда доля пересекающихся частотных слов равна `2 / 4 = 0.5`.

Функция принимает на вход два языковых профиля и число топ N слов.

Функция должна возвращать объект типа `float`. 

Если на вход подаются некорректные значения, возвращается `None`.

Для получения топ N слов необходимо использовать функцию `get_top_n_words`.

Интерфейс: 
```py
def compare_profiles(unknown_profile: dict, profile_to_compare: dict, top_n: int) -> float or None:
  pass
```

### Шаг 7. Определить язык неизвестного текста. Выполнение Шагов 1-7 соответствует 6 баллам


Функция принимает на вход языковой профиль на неизвестном языке, два языковых профиля на известных и число топ N слов.

Функция определяет язык текста на основе доли пересекающихся частотных слов.
Функция возвращает название языка с наибольшей долей пересекающихся частотных слов. 
Название языка находится в языковом профиле.
Если у двух языков одинаковое значение доли пересекающихся частотных слов,
отсортируйте названия языков в алфавитном порядке и возьмите первое.

Если на вход подаются некорректные значения, возвращается `None`.

Для нахождения доли пересекающихся частотных слов необходимо использовать функцию `compare_profiles`.

Интерфейс: 
```py
def detect_language(unknown_profile: dict, profile_1: dict, profile_2: dict, top_n: int) -> str or None:
  pass
```


### Шаг 8. Сравнить два языковых профиля (усложнение)

Функция принимает на вход языковой профиль на неизвестном языке, языковой профиль на известном и число топ N слов.

Функция возвращает отчет вида:
```
{'name': 'en',
 'common': ['a', 'and'], 
 'score': 0.6666666666666666, 
 'max_length_word': 'bartender', 
 'min_length_word': 'a', 
 'average_token_length': 4.095238095238095, 
 'sorted_common': ['a', 'and']}
```
где ключу `"name"` соответствует название языка,
`"common"` – топ N пересекающихся частотных слов,
`"score"` – доля пересекающихся частотных слов,
`"max_length_word"` – слово с максимальным количеством букв,
`"min_length_word"` – слово с минимальным количеством букв,
`"average_token_length"` – среднее количество букв в словах,
`"sorted_common"` – отсортированные по алфавиту топ N пересекающихся частотных слов.

Для получения топ N пересекающихся частотных слов необходимо использовать функцию `get_top_n_words`.

Если на вход подаются некорректные значения, возвращается `None`.

Интерфейс: 
```py
def compare_profiles_advanced(unknown_profile: dict, profile_to_compare: dict, top_n: int) -> list or None:
  pass
```


### Шаг 9. Определить язык неизвестного текста (усложнение). Выполнение Шагов 1-9 соответствует 8 баллам

Вы должны понимать, что для определения языка может быть недостаточно двух языковых профилей.
На самом деле в данной задаче может использоваться произвольное количество языковых профилей (например, 30).

С другой стороны, большое количество профилей может привести к значительному увеличению времени детектирования.
Одним из способов решения данной проблемы является ограничение списка возможных языков.
Для этого в детектор передается список возможных языков, например `['en', 'de']`, 
и тогда для определения языка используются только профили конкретных языков (что уменьшает временные затраты).

На данном шаге вам нужно расширить функционал уже построенного детектора, 
добавив возможность работы с произвольным количеством профилей и возможность ограничивать список возможных языков.
Для этого добавьте в `start.py` обработку латинского текста из папки `'texts'`
и попробуйте определить язык неизвестного текста только на основе латинского и немецкого.

Функция принимает на вход языковой профиль на неизвестном языке, список языковых профилей на известных, 
список возможных языков и число топ N слов.

Если список возможных языков пуст, определение языка производится на основе **всех доступных языковых профилей**.
Если список содержит какие-либо языки, 
определение языка производится только на основе **профилей конкретных языков**.

Функция определяет язык текста на основе доли пересекающихся частотных слов.
Функция возвращает название языка с наибольшей долей пересекающихся частотных слов. 
Название языка находится в языковом профиле.
Если у двух языков одинаковое значение доли пересекающихся частотных слов,
отсортируйте названия языков в алфавитном порядке и возьмите первое.

Если на вход подаются некорректные значения, возвращается `None`.

Для нахождения доли пересекающихся частотных слов необходимо использовать функцию `compare_profiles_advanced`.

Интерфейс: 
```py
def detect_language_advanced(unknown_profile: dict, profiles: list, languages: list, top_n: int) -> str or None:
  pass
```


### Шаг 10. Работа с файлами. Выполнение Шагов 1-10 соответствует 10 баллам

В рамках модуля `start.py` вы работаете с маленькими текстами. 
Но представьте, что вам нужно обработать огромный корпус текстов и получить по ним языковой профиль.
Сколько времени занимает данная обработка? 
Хотели ли бы вы её выполнять каждый раз при определении языка неизвестного текста?

Созданный языковой профиль необходимо сохранять в файл для дальнейшего использования.
В последующие разы языковой профиль необходимо загружать из уже созданного ранее файла.

Функция `load_profile` принимает на вход путь к файлу с расширением `.json` с языковым профилем.
Содержимое данного файла представляет собой словарь вида:
```
{"name": "en",
"freq": {"happy": 2, "the": 1},
"n_words": 2}
```
где ключу `"freq"` соответствует значение – частотный словарь, 
ключу `"n_words"` – количество токенов в словаре,
ключу `"name"` – название языка.

Функция `load_profile` должна возвращать словарь.

Если на вход подаются некорректные значения, возвращается `None`.

Функция `save_profile` принимает на вход языковой профиль и 
записывает его в файл с расширением `.json` в вышеназванном формате. 
Название файла - `*.json`, где `*` – это название языка. Файл должен лежать в папке `'lab_1'`.

Функция `save_profile` возвращает `0`, если запись в файл прошла успешно.

Если на вход подаются некорректные значения, возвращается `1`.

Для записи и загрузки языкового профиля **необходимо использовать библиотеку `json`.**

В `start.py` вам необходимо продемонстрировать определение языка при помощи внешних языковых профилей, 
которые вы найдете в папке `'profiles'`.
Сравните результаты определения языка на основе ваших и внешних (загруженных) языковых профилей.

Интерфейс: 
```py
def load_profile(path_to_file: str) -> dict or None:
  pass
```

```py
def save_profile(profile: dict) -> int:
  pass
```
